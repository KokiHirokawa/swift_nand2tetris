# Nand2Tetris

## Hack機械語
### A命令
- Aレジスタに15bitの値を設定するための命令
- @value
- 0vvv vvvv vvvv vvvv (v = 0 or 1)
- 3つの異なる用途
    - 定数の代入
    - メモリ操作（Aレジスタにメモリアドレスをセットし、次のC命令で該当のメモリ位置にあるデータを操作）
    - 移動命令（移動先のメモリアドレスをセットし、次のjump命令で該当の位置の命令を実行）
### C命令
- コンピュータに命令を実行させる
- dest=comp;jump
- 111a cccc ccdd djjj (c = comp, d = dest, j = jump)

#### comp
| if a = 0 | comp | if a = 1 |
|-:|:-:|:-|
| 0   | 101010 |     |
| 1   | 111111 |     |
| -1  | 111010 |     |
| D   | 001100 |     |
| A   | 110000 | M   |
| !D  | 001101 |     |
| !A  | 110001 | !M  |
| -D  | 001111 |     |
| -A  | 110011 | -M  |
| D+1 | 011111 |     |
| A+1 | 110111 | M+1 |
| D-1 | 001110 |     |
| A-1 | 110010 | M-1 |
| D+A | 000010 | D+M |
| D-A | 010011 | D-M |
| A-D | 000111 | M-D |
| D&A | 000000 | D&M |
| D|A | 010101 | D|M |

#### dest
| dest | mnemonic |
|:-:|:-:|
| 000 | null |
| 001 | M    |
| 010 | D    |
| 011 | MD   |
| 100 | A    |
| 101 | AM   |
| 110 | AD   |
| 111 | ADM  |

#### jump
| dest | mnemonic | effect |
|:-:|:-:|:-|
| 000 | null | no jump |
| 001 | JGT  | if out > 0 jump |
| 010 | JEQ  | if out == 0 jump |
| 011 | JGE  | if out >= 0 jump |
| 100 | JLT  | if out < 0 jump |
| 101 | JNE  | if out != 0 jump |
| 110 | JLE  | if out <= 0 jump |
| 111 | JMP  | jump |

### シンボル
#### 定義済みシンボル
| label | RAM address |
|-:|:-:|
| SP     | 0 |
| LCL    | 1 |
| ARG    | 2 |
| THIS   | 3 |
| THAT   | 4 |
| R0-R15 | 0-15 |
| SCREEN | 16384 |
| KBD    | 24576 |

#### ラベルシンボル
- (Xxx) は次のコマンドの位置を参照する。

#### 変数シンボル
- 定義済みシンボルでもラベルシンボルでもない変数。
- 最初に変数に遭遇したときにメモリが順に割り当てられる。





## VM仕様
### コマンド
<dl>
    <dt>算術コマンド</dt>
    <dd>スタック上で算術演算と論理演算を行う</dd>
    <dt>メモリアクセスコマンド</dt>
    <dd>スタックとバーチャルメモリ領域の間でデータの転送を行う</dd>
    <dt>プログラムフローコマンド</dt>
    <dd>条件付き分岐処理または無条件の分岐処理を行う</dd>
    <dt>関数呼び出しコマンド</dt>
    <dd>関数呼び出しとそれらからのリターンを行う</dd>
</dl>

#### 算術コマンド
| command | return value |
|:-:|:-:|
| add | x + y |
| sub | x - y |
| neg | -y |
| eq | x == y |
| gt | x > y |
| lt | x < y |
| and | x And y |
| or | x Or y |
| not | !y |

#### メモリアクセスコマンド
<dl>
    <dt>push segment index</dt>
    <dd>segment[index]をスタック上にプッシュする</dd>
    <dt>pop segment index</dt>
    <dd>スタックの一番上のデータをポップしsegment[index]に格納する</dd>
</dl>

| segment | aim | comment |
|:-:|:-|:-|
| argument    | 関数の引数を格納する| 関数に入るとVM実装によって動的に割り当てられる |
| local       | 関数のローカル変数を格納する | 関数に入るとVM実装によって動的に割り当てられ0に初期化される |
| static      | スタティック変数を格納する | 各.vmファイルに対してVM実装によって動的に割り当てられる。.vmファイルの全ての関数で共有される |
| constant    | 0-32767までの範囲の全ての定数値を持つ擬似セグメント |  VM実装によってエミュレートされる。プログラムの全ての関数から見える |
| this / that | 汎用セグメント。異なるヒープ領域に対応するように作られている | ヒープ上の選択された領域を操作するために、どのような関数でもこれらのセグメントを使うことができる |
| pointer     | thisとthatセグメントのベースアドレスを持つ2つの要素からなるセグメント | VMの関数でpointerの0番目（または1番目）をあるアドレスに設定することができる。これによりthis（またはthat）セグメントをそのアドレスで開始するヒープ領域に設定する |
| temp        | 固定された8つの要素からなるセグメント。一時的な変数を格納する | 目的に応じてM実装によって使われる。プログラムの全ての関数で共有される |

### RAMの使用法
| RAM address | description |
|-:|:-|
| 0-15        | 16この仮想レジスタ |
| 16-255      | スタティック変数 |
| 256-2047    | スタック |
| 2048-16383  | ヒープ（オブジェクトと配列を格納する） |
| 16384-24575 | メモリマップドI/O |
| 24576-32767 | 使用しないメモリ空間 |

| Register | name | description |
|-:|:-:|:-|
| RAM0     | SP   | スタックポインタ。スタックの最上位の次のアドレスを示す |
| RAM1     | LCL  | 現在のVM関数におけるlocalセグメントのベースアドレスを示す |
| RAM2     | ARG  | 現在のVM関数におけるargumentセグメントのベースアドレスを示す |
| RAM3     | THIS | 現在のthisセグメントのベースアドレスを示す |
| RAM4     | THAT | 現在のthatセグメントのベースアドレスを示す |
| RAM5-12  |      | tempセグメントの値を保持する |
| RAM13-15 |      | 汎用的なレジスタとしてVM実装で用いることができる |

### メモリセグメントマッピング
<dl>
    <dt>local, argument, this, that</dt>
    <dd>これらのセグメントにおいてi番目の要素へのアクセスは、RAM内の（base + i）番目のアドレスへアクセスするアセンブリコードへと変換される</dd>
    <dt>pointer, temp</dt>
    <dd>pointerセグメントはRAM3-4（THIS, THAT）にマッピングされ、tempセグメントはRAM5-12にマッピングされる。そのため「pointer i」によるアクセスはRAM内の（3 + i）番目のアドレスへ、「temp i」は（5 + i）番目のアドレスへとアクセスするアセンブリコードへと変換される</dd>
    <dt>constant</dt>
    <dd>このセグメントは対象のアーキテクチャ上で物理領域を占有しないため完全に仮想的な存在である。VM実装は「constant i」というアクセスを単に定数値のiとして扱う</dd>
    <dt>static</dt>
    <dd>アセンブリプログラム内で新しいシンボルに最初に遭遇した際、アセンブラはそのシンボルに新しいRAMアドレスを割り当てる。このRAMアドレスは16番目から始まるアドレスである</dd>
</dl>