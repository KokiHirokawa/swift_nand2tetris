
## Hack機械語
### A命令
- Aレジスタに15bitの値を設定するための命令
- @value
- 0vvv vvvv vvvv vvvv (v = 0 or 1)
- 3つの異なる用途
    - 定数の代入
    - メモリ操作（Aレジスタにメモリアドレスをセットし、次のC命令で該当のメモリ位置にあるデータを操作）
    - 移動命令（移動先のメモリアドレスをセットし、次のjump命令で該当の位置の命令を実行）
### C命令
- コンピュータに命令を実行させる
- dest=comp;jump
- 111a cccc ccdd djjj (c = comp, d = dest, j = jump)

#### comp
| if a = 0 | comp | if a = 1 |
|-:|:-:|:-|
| 0   | 101010 |     |
| 1   | 111111 |     |
| -1  | 111010 |     |
| D   | 001100 |     |
| A   | 110000 | M   |
| !D  | 001101 |     |
| !A  | 110001 | !M  |
| -D  | 001111 |     |
| -A  | 110011 | -M  |
| D+1 | 011111 |     |
| A+1 | 110111 | M+1 |
| D-1 | 001110 |     |
| A-1 | 110010 | M-1 |
| D+A | 000010 | D+M |
| D-A | 010011 | D-M |
| A-D | 000111 | M-D |
| D&A | 000000 | D&M |
| D|A | 010101 | D|M |

#### dest
| dest | mnemonic |
|:-:|:-:|
| 000 | null |
| 001 | M    |
| 010 | D    |
| 011 | MD   |
| 100 | A    |
| 101 | AM   |
| 110 | AD   |
| 111 | ADM  |

#### jump
| dest | mnemonic | effect |
|:-:|:-:|:-|
| 000 | null | no jump |
| 001 | JGT  | if out > 0 jump |
| 010 | JEQ  | if out == 0 jump |
| 011 | JGE  | if out >= 0 jump |
| 100 | JLT  | if out < 0 jump |
| 101 | JNE  | if out != 0 jump |
| 110 | JLE  | if out <= 0 jump |
| 111 | JMP  | jump |

### シンボル
#### 定義済みシンボル
| label | RAM address |
|-:|:-:|
| SP     | 0 |
| LCL    | 1 |
| ARG    | 2 |
| THIS   | 3 |
| THAT   | 4 |
| R0-R15 | 0-15 |
| SCREEN | 16384 |
| KBD    | 24576 |

#### ラベルシンボル
- (Xxx) は次のコマンドの位置を参照する。

#### 変数シンボル
- 定義済みシンボルでもラベルシンボルでもない変数。
- 最初に変数に遭遇したときにメモリが順に割り当てられる。





## VM仕様
### コマンド
<dl>
    <dt>算術コマンド</dt>
    <dd>スタック上で算術演算と論理演算を行う</dd>
    <dt>メモリアクセスコマンド</dt>
    <dd>スタックとバーチャルメモリ領域の間でデータの転送を行う</dd>
    <dt>プログラムフローコマンド</dt>
    <dd>条件付き分岐処理または無条件の分岐処理を行う</dd>
    <dt>関数呼び出しコマンド</dt>
    <dd>関数呼び出しとそれらからのリターンを行う</dd>
</dl>

#### 算術コマンド
| command | return value |
|:-:|:-:|
| add | x + y |
| sub | x - y |
| neg | -y |
| eq | x == y |
| gt | x > y |
| lt | x < y |
| and | x And y |
| or | x Or y |
| not | !y |

#### メモリアクセスコマンド
<dl>
    <dt>push segment index</dt>
    <dd>segment[index]をスタック上にプッシュする</dd>
    <dt>pop segment index</dt>
    <dd>スタックの一番上のデータをポップしsegment[index]に格納する</dd>
</dl>

| segment | aim | comment |
|:-:|:-|:-|
| argument    | 関数の引数を格納する| 関数に入るとVM実装によって動的に割り当てられる |
| local       | 関数のローカル変数を格納する | 関数に入るとVM実装によって動的に割り当てられ0に初期化される |
| static      | スタティック変数を格納する | 各.vmファイルに対してVM実装によって動的に割り当てられる。.vmファイルの全ての関数で共有される |
| constant    | 0-32767までの範囲の全ての定数値を持つ擬似セグメント |  VM実装によってエミュレートされる。プログラムの全ての関数から見える |
| this / that | 汎用セグメント。異なるヒープ領域に対応するように作られている | ヒープ上の選択された領域を操作するために、どのような関数でもこれらのセグメントを使うことができる |
| pointer     | thisとthatセグメントのベースアドレスを持つ2つの要素からなるセグメント | VMの関数でpointerの0番目（または1番目）をあるアドレスに設定することができる。これによりthis（またはthat）セグメントをそのアドレスで開始するヒープ領域に設定する |
| temp        | 固定された8つの要素からなるセグメント。一時的な変数を格納する | 目的に応じてM実装によって使われる。プログラムの全ての関数で共有される |

### RAMの使用法
| RAM address | description |
|-:|:-|
| 0-15        | 16この仮想レジスタ |
| 16-255      | スタティック変数 |
| 256-2047    | スタック |
| 2048-16383  | ヒープ（オブジェクトと配列を格納する） |
| 16384-24575 | メモリマップドI/O |
| 24576-32767 | 使用しないメモリ空間 |

| Register | name | description |
|-:|:-:|:-|
| RAM0     | SP   | スタックポインタ。スタックの最上位の次のアドレスを示す |
| RAM1     | LCL  | 現在のVM関数におけるlocalセグメントのベースアドレスを示す |
| RAM2     | ARG  | 現在のVM関数におけるargumentセグメントのベースアドレスを示す |
| RAM3     | THIS | 現在のthisセグメントのベースアドレスを示す |
| RAM4     | THAT | 現在のthatセグメントのベースアドレスを示す |
| RAM5-12  |      | tempセグメントの値を保持する |
| RAM13-15 |      | 汎用的なレジスタとしてVM実装で用いることができる |

### メモリセグメントマッピング
<dl>
    <dt>local, argument, this, that</dt>
    <dd>これらのセグメントにおいてi番目の要素へのアクセスは、RAM内の（base + i）番目のアドレスへアクセスするアセンブリコードへと変換される</dd>
    <dt>pointer, temp</dt>
    <dd>pointerセグメントはRAM3-4（THIS, THAT）にマッピングされ、tempセグメントはRAM5-12にマッピングされる。そのため「pointer i」によるアクセスはRAM内の（3 + i）番目のアドレスへ、「temp i」は（5 + i）番目のアドレスへとアクセスするアセンブリコードへと変換される</dd>
    <dt>constant</dt>
    <dd>このセグメントは対象のアーキテクチャ上で物理領域を占有しないため完全に仮想的な存在である。VM実装は「constant i」というアクセスを単に定数値のiとして扱う</dd>
    <dt>static</dt>
    <dd>アセンブリプログラム内で新しいシンボルに最初に遭遇した際、アセンブラはそのシンボルに新しいRAMアドレスを割り当てる。このRAMアドレスは16番目から始まるアドレスである</dd>
</dl>

## コンパイラ
- 構文解析
    - トークナイザ
        - ソースコードに対して意味を持つコードの最初単位である「トークン（字句）」に変換する
    - パーサ
        - 一連のトークンを言語の構文ルールに適合させ、その構文構造を明らかにする
- コード生成
    - hogehoge

### 構文解析器
構文解析器の目的は「プログラムの構造を理解する」こと
- 字句解析
- 文脈自由文法
- 構文木
- 再帰降下アルゴリズム

#### 字句解析
文字のグループをトークンとしてまとめる
```c
while (count <= 100) {
    count++;
    // Body of while continues
    ...
}
```
```
while
(
count
<=>
100
)
{
count
++
;
...
}
```

#### 文脈自由文法
ある言語の構文要素がより単純な要素からどのように構成されるか、ということを指定したルールの集合
- （宣言を行う視点から見ると）文法は終端要素を非終端要素へ組み合わせる方法を指定する
- （分析を行う視点から見ると）与えられた入力を非終端要素へ、そしてより低水準な非終端要素へ、さらにそれ以上分解できない終端要素へとパースする

#### 構文木
文法が入力テキストを正しいものとして受理するかどうかを確認する作業。文法のルールは階層的な構造であるため、パーサによって生成される出力は木の形をしたデータ構造となり「構文木」や「導出木」と呼ばれる

#### 再帰降下アルゴリズム
言語の文法によって規定されるネスト化された構文を使って、トークンの列に対して再帰的に構文解析を行う